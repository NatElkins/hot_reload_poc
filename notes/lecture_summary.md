# How does Hot Reload even work? - David Wengier - NDC Sydney 2022

https://www.youtube.com/watch?v=tVmABHwxuqE

### Table of contents
- [0:00:02](https://youtu.be/tVmABHwxuqE?t=2) [Understanding .NET Assembly and Metadata](#understanding-net-assembly-and-metadata)
- [0:12:28](https://youtu.be/tVmABHwxuqE?t=748) [Understanding Hot Reload](#understanding-hot-reload)
- [0:24:50](https://youtu.be/tVmABHwxuqE?t=1490) [IL Spy and ECMA 335](#il-spy-and-ecma-335)
- [0:26:47](https://youtu.be/tVmABHwxuqE?t=1607) [Visual Studio Demo: Hot Reload and IL Metadata](#visual-studio-demo-hot-reload-and-il-metadata)
- [0:57:40](https://youtu.be/tVmABHwxuqE?t=3460) [.NET 6 Hot Reload Discussions](#net-6-hot-reload-discussions)

## Understanding .NET Assembly and Metadata<a name="understanding-net-assembly-and-metadata"></a>

em.

Welcome, everybody! So, this is how does Hot Reload even work. I'm kinda gonna tell you a little bit of it. I cant tell you everything because it takes too long. I'm gonna tell you a bit that I found really interesting when I learnt this as part of having to work on Hot Reload, so I hope you find it interesting too. But, Hot Reload is a little bit of a funny term because it is partly a feature, and it is partly a little bit marketing. So, just to be very clear, the bit of Hot Reload I'm talking about is applying changes that we make to code into .NET assembly while it's running. I'm not gonna talk about all of these things, but later when I ask for questions, if any of them are interesting, there's some hints. Feel free. There is way more to this. There's lots of messy details and I'm just gonna completely gloss over them for the purposes of time.

So, the key thing here is .NET assembly. And so, before I can tell you how Hot Reload works, I have to tell you what a .NET assembly is. Maybe you know, maybe you don't. You're gonna find out.

So, what's in a .NET assembly?

So, this is a screenshot of ILSpy by maybe some of you have used it. It's an open source project, you should.

A .NET assembly consists of two main parts. There is metadata, the metadata meaning data describing the thing. So, this describes your DLL. Specifically in the metadata, there is metadata tables. That's what we'll be looking at. And then, of course, there's your code. They're the two things in an assembly. And, of course, hopefully, we'll know your C# code is not really in the assembly. It's actually IL. And, sadly, we have to talk a little bit about IL, which is sad because I tried to avoid it in life, but sometimes you can't.

So, let's talk about metadata tables. This is ILSpy's view of the metadata tables. And, I look at this, and I see that they're called tables, and I look at these grids with columns and rows, and I think this looks like a relational database. And, if this was a database conference, I might be kicked out for saying that there's a relational database inside your .NET assembly. If this was a .NET conference, I might get kicked out for that too. But, I think there's a little relational database at the start of your .NET assembly. There are primary keys. This is a metadata token, 0x2001. I think that was right number rows. This is the primary key of this row in the TypeDef table, TypeDef meaning type definition. If you look across to the name column, this module will ignore that. Don't know what that is. But, the next row says Program, that's the Program class. So, there's a row in a database that describes the Program class, and it has a primary key of 0x2001.

Sorry, don't know my classes. There's also foreign keys. So, part of types is methods, and so we have a method list column in our database. And, if we look at row 2, we can see the method list is 0x6, 0x0, 0x1. And, if we look across at the method table, there's a primary key, 0x6, 0x0, 0x1. So, that's a foreign key. Now, it's kind of a weird foreign key, because it's kind of backwards, right?

Normally, you would say, well, if you were designing a database, the method tables should have a field that maps to the TypeDef table. So, I get that it's a bit funny, but there's lots of compromises made in this mini-relational database. For two main reasons, number one is efficiency. We want to store, essentially, store as little data as possible, because we produce a lot of DLL files, and they can get very big, because all of you write lots of code. So, we want the metadata to be as small as it can be. And, then the other reason is efficiency. We have to read this in for every DLL as part of running the code, and so we want to be able to read it efficiently. And, the way this is achieved is there's two, well, there's one trick and one assumption. So, the trick is in the metadata token. So, what I described as a primary key, it's an integer, a four-byte number. And, if you're one of these annoying developers who likes to be really performant, which, of course, people who design things like the ECMA-335 spec tend to be, you see an integer and you think how much stuff can I cram in there. So, the first byte tells you the table that this primary key comes from. That's really weird for databases, I get it. Go with me. And, then the next three bytes tell you the row number. So, this does mean that there's a limit to how many methods you can put in your .NET assembly. Because, once you've got more than three bytes worth, bad luck, compiler. There's a limit to how many strings you can put in, so I'm reason. We actually hit this limit in our test classes, it's actually quite funny. We have to split them up in multiple projects. But, so, these primary keys, the trick to them is that they encode in the ID what table they come from. So, if we look at this method list column, which is actually a terrible example for what I'm saying, because the column is called method list, like where else is it going to point? But, you know, you could imagine maybe it said member list, and it was just a list of members that could be any type. We could know the type from the ID, right?

0x6, that points to the method table. See this field list, that's 0x4, 0, 0, 0, 0, 0, 0. There's no fields in this type, so there's no row 0, 0 means nothing. But, 0x4, I don't know, because I haven't read the spec, but I suspect the field table is table 4. If we look at base type, 0x1, 0, 0, 0, d. So, you start to look at these database tables of lots and lots of funny numbers and bytes, and you think who can understand this. And, actually, they kind of start to make sense, scarily enough. And if we go look up 0x1, the 0x1 table, which is the TypeRef table, so there's types defined in your assembly, and there's types referenced by your assembly, and they're stored separately. So, we go look up the TypeRef table, we find a record that says 0x1, 0, d, and its name is Object. And, that makes sense, because Program class inherits from Object. Now, in C#, we don't need to specify that, right? It's assumed. In .NET, in metadata to describe in your DLL, it's not C#. So, that assumption maybe doesn't exist. So, this DLL clearly says, there's a type called Program, it inherits from Object. And, in fact, we can go further with that, and I'll show you in a minute, but, like, that 0x23 0x1 actually points to the DLL that Object was found in. There's no assumptions in here at all, which is something to remember, because it's a bit weird. C# is high-level language. This is, you know, it's not a language, but, like, it's much below level. But, so, using this trick, we get really expressive data, which lets us have less data, which is good for our efficiency thing. So, for example, there's a table that stores attributes. You know, you put attribute on a method, a property, a type, etc. There's a table that stores them. It has a more normal foreign key. It has a parent column. The parent for any attribute tells you which thing the attribute is applied to. And, that's all it needs. All it needs is a parent column that is a token. And, those tokens, they already tell you what type of object it is. And, so, you know, the little wires go off and whatever. So, it's a very efficient way of storing. We get in four bytes of information, we can know exactly what an attribute is applied to. So, it's quite efficient. So, efficiency is goal number one. The other thing that's weird about these tokens is, well, so, the database is weird because it doesn't exist at all, right? Then, you press build, the compiler writes it out entirely, stops writing it, and then nothing ever touches the database ever again. And, that assumption allows for more optimizations. So, for example, metadata tokens, they always start at row number one. There are never any gaps. And, there is a very well-defined order for the rows in any table. It's defined in the spec. And, so, knowing that, the other weird trick about metadata tables is these primary keys. They don't actually exist because you don't need them. You know the rows start at one. You know what table you're reading. You can compute any key. I'm reading row one. Therefore, the key is 0x0601, because I'm reading the method table. And, so, we get efficiency again by just not storing a bunch of data, which is really cool, but it will come off later. So, remember that. You start to see these metadata tokens and the type table things everywhere, especially ILSpy does a great job of showing you. So, ILSpy is showing you there. So, method is table six. And, there's two rows in it. That's where the brackets are. The other place these tokens come up is, of course, in our IL. So, ILSpy is showing that this method calls System.Console.WriteLine. But, that's ILSpy being nice. Really what the IL says is there's the call opcode, which is, you know, some bytes that maps to some enums somewhere that no human can read. And, then there's another four bytes, which is the token for what to call. This is again, where our encoding our token type or our table name comes in handy. We could call a method defined in this assembly. We could call a method defined in another assembly. We don't need to tell, we don't need to have separate IL instructions for those two because the token tells us what type of thing we're doing. So, this is 0xA. That's MemberRef. So, remember we can define things and we can reference things. They're stored separately. So, MemberRef, why we went from method to member doesn't matter. Ignore that. I probably have said the wrong word hard time. So, we go look up that table. It was row C. This is all hex, obviously. It was row C. So, we find that. That's the WriteLine method. It has a parent. That's a foreign key. What does it point to? Push the TypeRef.

Okay, go look that up. Well, that's the Console type. That has a resolution scope. Call it what you want. We looked that up and that's in the assembly reference. So, that comes from System.Console. So, this is the level of detail that metadata has. Right? When you call System.WriteLine, in your IDE, you can hover over it and you can see it comes from the System namespace. We don't really in the IDE. We don't really expose the DLL it comes from. But you can see it if you go through properties. The metadata, however, doesn't show the DLL. It shows the assembly name. But finding the DLL is up to the runtime. And this is where we have type forwarding and we have done it. Standard versus done it thing. And we look up MS call, we've been the GAC and all that stuff. All that stuff is separate. This is kind of a thing that makes DLL is really portable too because they encode everything about what they're calling.

I am calling System.Console.WriteLine. And I expect it to be an assembly called System.Console. But then I stop there and I don't care where you find System.Console. And if you find it because you have some weird, you know, wasm compiled, JavaScript, Asm, whatever thing find.

## Understanding Hot Reload<a name="understanding-hot-reload"></a>

Okay, call my method. So, that's really cool. And that's really powerful because it all came from this one metadata token that says, please call 0xAC, whatever that means. And the runtime works out. So how does hot reload work? Glad you asked. So hopefully remember all that. That's the useful bit of the talk. That's the bit of the talk you maybe can like, you know, go forth and use that knowledge at work. Maybe the rest not so much.

Boy, I talk fast. All right. This is, I'm going to assume this is your conceptual model of hot reload. Obviously, for the purposes of comedic timing, this is completely wrong, but we'll talk about it anyway.

So logically speaking, what happens? We write some code. We start in the bottom right, but don't worry about that. It's just my PowerPoint skills. We write some code. We compile it. We send it to the runtime. The runtime runs it. But then we want to keep writing code. And we want to compile it again. And we send that off to the runtime. And the reason this doesn't happen, or the reason this isn't how hot reload works, is back to efficiency, speed, all those things. If we had to compile your whole project every time you changed code, that would be slow, and you would complain. And if we were to give the runtime an entire DLL or set of DLLs every time, then it would have a lot of work to do to try to work out what that means. The reason for this, or the thing to remember about hot reload in this case, is it's not just applying the changes, but it's maintaining the state in your application. That's the hard bit. Just applying changes. Easy. That's essentially like, if you think about a web browser, you navigate deeply through a web site. If you refresh the page, you're still at that page. So you don't have to renavigate again, but you've lost all of your state. And so it's not as much fun. So the keeping the states of the hot reload.

Anyway, so this is more likely how hot reload works. So we start on the top left this time, confusingly. So we write some code. We create a compilation. Great. Send it to the runtime.

Sure. That was good. But now we edit some more code. And the first thing we have to do is we have to work out what has changed. Again, efficiency. We only want to compile the bits that we want. We don't want to compile the whole thing. And there's a bunch of fancy algorithms in Roslyn that do this. There's a lot longest common subsequence. I think it's called. It's like you open up the file on GitHub and at the top it says this is from this paper with a link to like a PDF. And all the variable names in it are like N and K and L, because that's what the paper says. And so therefore you cannot understand the word of it. But you just sort of trust it works. And you move on. But so we have to work out what's changed. And we have to importantly, we have to work out what's changed from a .NET perspective. Right? We're editing C#. We need to produce a .NET assembly. And they are strictly separate. And you'll be editing VB.NET. In theory, you could be editing F#, although they don't support it because Roslyn doesn't do F#, but they could. And so we have to think about these edits and we have to work out what's changed in terms of .NET. And that means in terms of the metadata tables.

So when I change a string in a method, Roslyn will analyze that code and it will use its syntax tree and it will say, ah, you've changed a string literal expression. And that's part of an expression. And it basically walks back up the tree until it hits a boundary of, ah, that's in a method. .NET knows about methods. So your edit in that case is an edit to the method. It doesn't actually matter what you've done in the method because if you think back to the metadata tables, not that I let you linger on the list of them, but you know, there's no, there's no metadata table for line of code. There's no metadata table for, you know, a block method is kind of the smallest, well, I guess fields are smaller, but anyway. So we work out what's changed. And we take our list of changes and we tell the compiler, hey, go and compile a Delta compilation. Delta meaning just the bits that have changed. And so our edit list is our to do list for the compiler. Here's the whole project, but here's your bits we want you to compile. The compiler produces that Delta compilation, which is just metadata, IL, it's all it is. It's the same compiler. It's the same, you know, same code path as compiling the full deal. We send that Delta to the runtime and the runtime applies the Delta. So the fact that it's a Delta, meaning it's just the changes, means the runtime doesn't have to work out what's changed. So it doesn't have to go and do any magic. So that's fast. The fact that we're telling the compiler what's changed so it doesn't have to compile everything that makes it faster, right? So the linchpin is working out what has changed and everything sort of flows from there. The active applying the Delta, the way that I like to think about it is, so we have our relational database in our metadata and it's right once, read only, never changes, all that stuff. The runtime essentially has a representation of that in memory for each assembly. And this is what you query with reflection. If you think about reflection being a query API over relational database, which obviously no one would ever do, but you can. This is kind of what you, the information you dig out when you say give me the types and you say give me the members. So it finds that record in the type table, right? Then you say give me the members. It goes, looks up the member list. And that's another sort of like key to understand this. You can't say give me the WriteLine method and then read the type of it. It doesn't work that way because the metadata doesn't work that way. You have to get the type first, right?

So applying the Delta is basically, here's our compilation of what's changed, the kind of update statements. Maybe it's a very long bow I'm drawing I realized. But anyway, let's work through an example. So here is a very small class and it has three methods. And here is our method, our method, def table for our baseline. Baseline is what we call the, the DLL, right? The thing you actually built. And so we have three rows. Now, they're tokens, three, four and five, just for illustrative purposes. What is not shown here is the constructor. Again, in C#, I don't need a constructor, but the compiler synthesizes one. Well, that means the compiler has to create a constructor and therefore it has to go in the metadata. .NET does not have the same assumptions of C#. So the constructor is one and then, I don't know, a main method for like, you know, running the class doesn't matter. So there are three, four and five. So we update method B. We change the string. Roslyn sees the change to the string. It goes right. Let me work out what that is. And we produce an edit that says, we have updated class.

B. Now, actually, class is probably a bad name for this class because the class then means the name of the class. Sorry. So we have, we have updated this. Well, I would call it a symbol. That's a bit of a Roslyn term, but anyway, this is the thing we're updating. And so then we say, hey compiler, go compile this type. We'll go compile this project. He's your to-do list. It's one item class of B. And so the compiler produces a generation.

Oh, I forgot to mention that. Every time through the loop of updating is called a generation. So for generation one, a delta compilation has a method def table that looks like this. Yes, it doesn't make sense, just wait. And so then we make another edit. We edit method A and method B to a version two of method A, version three of method B. Our edits have disappeared, which doesn't matter, but it just so happens that we don't know the edits after a generation has finished. It doesn't really matter to the process. It's just something I like to complain about because it makes my job a bit harder sometimes. So generation two, we have two updates. Class A and class B methods have been updated. And now we have a method def table with two rows in it. Cool. So hopefully you can all see the very obvious problem here. These IDs don't make any sense, right? If we're thinking this is an update statement, we have just ruined everything because how did method B, method B in this one slide is ID 4, ID 1, and ID 2. Clearly it doesn't work. So the key to hot reload is there's a little bit of information that the compiler produces when it's producing a delta compilation that tells the runtime how to apply these updates. And it's essentially, well it's not essentially, it is a map and it's a map of IDs, a map of tokens. So before I get into that, why are they one and two? I'm going to make this interactive. Does anyone want to have a guess of why? Why is generation one method B, ID 1? Correct, first row. So this is where the fact that the tokens don't really exist is important, right?

There is an actually a token that says method B is token 1. It just so happens. We've asked the compiler to produce, to compile one method. It has compiled one method and written one row in our table. So when we read that table in, it's row 1. So there's no way for us to say in the method def table, this is actually row 4. So we need this extra map. So the map, well there's a map and there's a log. And it's two, two metadata tables, especially for hot reload or for editing to continue. ENC map and ENC log. And these are stored in the PDB which we haven't talked about. So PDB is, we have a metadata from our DLL and a PDB is just a bunch more data. That's all it is. And it's just metadata. There's no code in there. There's no IL. PDB stands for program database. Thank you.

Anyway, I'm not crazy, I promise. It's a relationship out of this. So the PDB contains a bunch of tables. And again, thinking about efficiency, the tables in the metadata in the DLL are the ones that are required for the runtime to run your code and everything else is in the PDB because you don't have to ship the PDBs to run your code. But they are things that help you with debugging scenarios like hot reload. And it's also why PDBs are usually very big because we try to keep as much as possible out of the main DLL. So there's things like the document table. The document table tells us the file name for every method type, every, well, every sequence point, which is a thing. That's how we get nice stack traces. And that's how go to definition can work sometimes. That's pulling data out of that table. We don't need to know what file name things came from to run the code, but it helps in debugging.

We have method debug information. It's kind of obvious. We have scopes because IL doesn't have scopes, but breakpoints local variables do. We have custom debug information, which I love because it's like, I don't know if this is true, but in my mind, they decided to name a bunch of tables. Like, oh, we're going to store this. We're going to store this. We're going to store this. And we just want to store a bunch of other stuff as well. And everything goes in custom debug information. Great. But of course, there's no ENC map and ENC log, so where is it?

Well, there's a setting in ILSpy called hide empty metadata tables. So you go and you turn that off. And now you can see a few more tables in the PDB file. We get state machine method. That's a good one. State machine has data about your async methods and your yield, your iterators because they become state machines. And so in order to debug and step through these state machines, we have to know the information.

Anyway, still no ENC log and ENC map.

## IL Spy and ECMA 335<a name="il-spy-and-ecma-335"></a>

Well, you know, okay, this is ILSpy. It's looking at a DLL. The Delta compilations never exist on disk. There's no such thing as a Delta DLL doesn't exist. So maybe that's why ILSpy doesn't. So you go look up the spec.

You look up ECMA 335 and you like, David told me there was an ENC log table. And you search for it in the spec and you find exactly one result. And it says, yeah, this is just used for editing. You don't worry about it. And if you're a conspiratorial person, you think Microsoft's trying to keep their secrets and stop JetBrains from using hot reload, which is, of course, because JetBrains has hot reload. The reality is, of course, developers are just really bad at documentation. And I say all this to introduce the next tool, ILSpy. I love ILSpy. It's very nice. It looks very nice. It's very friendly once you can see past all of the magic numbers and see them for the tokens they are. But now we have to talk about MDV. So MDV is a stance for metadata visualizer. And it was described to me with two sentences. The first sentence was, MDV is the only tool you ever need to look at metadata. Sounds good.

The second sentence was, MDV is designed for people who have read ECMA 335. I have not read ECMA 335. It's not actually that bad. It sounds scary to lose. But there's MDV. You can get it. You can install it. It's done at tool in a slight aside of conference talk driven development. Up until last week, you couldn't install as a .NET tool, but I had to get it on this machine. And I was so annoying building from source that I made it a .NET tool. I also wanted to do markdown outputs so I could show you the results nicely, but I ran out of time. And it probably wouldn't be, I wouldn't be that approved. The people who like MDV being for ECMA 335 readers, they also like that it's just text, and let us draw.

## Visual Studio Demo: Hot Reload and IL Metadata<a name="visual-studio-demo-hot-reload-and-il-metadata"></a>

Anyway, in 26 minutes, the longest I've ever gone without a demo. Any talk, let's jump to Visual Studio. This is my little code snippet, A, B, and C. This is a different project. Let me run it and I'll show you. The tokens are going to be different. I'm going to be 4, 5, and 6. I don't know what it's going to be. We'll find out.

This is just a little program. It doesn't look like you're on the screen. Just a little console app. It just runs a tight loop and runs these methods. You can see the clock here ticking away just to prove that nothing's fake. And outputs, what it outputs. And on the right here, we have essentially just looking in reflection at what's in the Program class. This is just outputting what's in reflection.

And so, if I do my change to method V2 and I press the hot reload button, we can see hello from B, V2 has been updated. A code's updated. No changes on the right hand side. So still only one method called B according to reflection. So we have successfully hot reloaded.

Well done, everyone. And I'll now make my other change that I said I would.

B3. That worked too. Great. So scary pressing that button, because if it doesn't work. So that's the demo. Obviously, I haven't shown you MDV yet. That's because I wanted to get both generations out of the way first.

Actually, I'm going to close this.

So in Visual Studio, I have a special flag set that dumps information, like you know, diagnostic stuff about hot reload when it does a hot reload. And it dumps it to this folder. And I can see two. That means it's my second session of the day, the first session being in the previous talk when I practice to make sure this would work. And I can go into my app. And so here, I have everything that hot reload produced. Normally, this doesn't, you know, I said, it doesn't do this on disk, obviously, but you've got to sit this like. So what we have here is, we have our DLL. This is our baseline. And our PDB that matches it. We have the C# files. This is for debugging roles and stuff. We're not going to worry about that. Plus you know what it says because you saw me do it. And then we have for each generation, we have the IL Delta, the metadata Delta, and the PDB Delta, which is more metadata. And so we run MDV and it just goes in. It knows about this file structure. So it does stuff. Obviously, I will not expect you to read all of that. So let me do this and open it up. And we're good for size. Cool.

Okay. So MDV dumps out everything it found. So the first thing it's going to dump out is our baseline, right? Generation zero is what it calls it. Great. And so this is just every metadata table. So we have TypeRef. I love this because there are there are 20. There's not 20. But you know, there's lots of rows of TypeRefs. This was a very small project. It doesn't do much. But all these attributes, the compiler has to eject, all that has to exist in metadata. I just love how big it is. And then we have TypeDefs. So these are types defined, right? There's a few attributes which the compiler creates for us. These are in basically every DLL. This is my class that does the reflection output thing. But here's our Program class. And interestingly, if we look over at the methods.

So ILSpy says method list.

MDV says methods. ILSpy gives you one token. Excuse me. MDV gives you a range. Because of how the metadata tables work and they're just like it's just raw bytes. And you have to know what you're reading.

Oh, I've got to the end. There's count for each table. So you know how many rows to read. And there's a format for each table. So you know how many columns to read and all this stuff. So the names are these things. There's not a lot of like there's no metadata or about your metadata to make to give it friendly names. So MDV is being nice and showing us the end method for this type. Again, that doesn't really exist because you don't need it. Because you read in all of the types. Now you loop through the types reading methods. And so you know when to stop.

So anyway, so for our main class, we've got from 8 to C. Cool. Our Program class, sorry. Much fields. And then here we are. Here is our A, B and C methods. So where what are we? 9, A and B. Okay. Fun. We'll remember that. Here's our synthesized constructor. Here's our main method. There's like lots of constructors. Great. So that's cool. 8, 9 and 10. Great. We can go down and we can see the IL, which no, I don't know if this is going to make any sense. Do, do, do, do, nope, nope, nope. There we are. Nope. That's not it. Hang on. I hate the fact that I can kind of read the IL.

Well, actually, I'm not. I'm reading the English. There we go. I'm not reading the actual opcodes. I've no idea what they do. But so here's our method A, because it says hello from A. Here's a method B. And you can see we have method, method out of tokens here.

9, A and B. So this is the IL for this row. So the IL is kind of like another field, but it's, yeah, stored separately because it's big can be. Cool. So that's our baseline. So generation one, here is our one method. So again, there's no primary key written down. It's just that it happens to be the first one. This is a problem. So here is the magic, right?

Here's the ENC log table. Here's the ENC map table. For the purposes of this demo, for updating a method, we don't need both. They're redundant. They have the same information. But there's various other scenarios where the log tells us a bit more and the map helps us out in other ways. Like it's to help the runtime. But for updating a method, it's, it's pretty straightforward. And the way this works, which maybe you can deduce based on everything I said about how metadata works in his red. Again, there's a distinct lack of information in this as far as I update this method. This says method def A. That's what it says. That's all it says, right? It's like, what do I do with that? Well, it turns out this is the first method def in the log. Therefore, it's method def one. But it's really method def A. And so that's how we tell the runtime which one to update. And then same thing in the map, this is the first method def in the map. The fact that this is at the end here and this is in the middle here is just because of the spec of this table and they contain different things. It doesn't matter. The order is defined. We know how it's going to be written. We know it'll never change. We know there won't be any gaps. And so we can make all of these assumptions. And the runtime has a bit of code that, you know, if the compiler changes how this is produced, just things will just crash, right? Like, everything will die. But for now, we live in this wonderful world of assumptions and everything works. And that's basically, I mean, that's it. That's how it really works. It's from method updates anyway. It's kind of actually, well, I think, surprisingly simple. We output a method. And then we say, yeah, that's that one. And then the runtime goes, okay, and it updates all the data. And in fact, the updating all the data is surprisingly simple too. Because remember, there's no primary case. All of these fields are just data about method one, which we now know is method A. And so we just update all the data. If we go further down, and we find some more IL, here's IL from B version two, the IL actually has the right method def already in it. So we don't even have to map that, right? This is using the original token, metadata is open for that method. Because all of those generations, all of the the baseline and the generations, they are all essentially in memory inside Roslyn while you're working. And so when we say, hey, compile method B, we go and look up. How was method B defined? Now, we have to look it up, and it's a little bit complicated, because of course, you could add a method in generation two. So we can't just go look in the baseline. So sometimes we have to do a little bit of math and go, well, it was added in two and then we're 10 in the baseline. So that means this is actually 11. And so sometimes that gets a bit confusing, but, you know, again, I'm the only one else to worry about that. And then here's our generation two. This looks much the same. We now have two methods, one and two. We have two methods in our ENC log, 9 and A. Again, it's the first method def and the second method def in the log. That's all. It's all just based on ordering. And in a complete and horribly anticlimactic talk, that's how it really works. So I do have a couple more slides, because I tend to talk faster. That was only 35 minutes. Actually, it's not too bad. I think I do 40 in practice. Does anyone have any questions about that? Want me to go into more detail? Anything?

Yes, hello. Yes. So the question was, when it sees the number in the map, does it just tell the runtime to append to that number? And essentially, yes. What the log is saying is, I mean, it's called a log, right? It's a log of what the compiler has done. So the compiler is essentially saying, I have output a row for the method def table, for token. And so the runtime will then go and get that row, quite a bit. Append versus update is a good point. So in this case, we're not appending, we're updating. So we're replacing, essentially, replacing row 9, A, whatever it is with a new one. But you can sometimes append, because you can add new methods. And so the ENC log has another field there, which was all zeros in my example. And that zero means update, and one means add. Like it's in fact, they're the only two values, I think. And so sometimes we say, hey, update the type, but we're adding a method. And so then for that, yeah, we tell it the new token, so we have to work out what the next method in line would be. But then the runtime has to go, okay, well, if you're adding a method to this type and remembering that everything has to be in order, right, we now have to essentially roll that new token forward through as we're reading like the method, that method list column, right?

Type A goes from one to two and type B goes from three to four, but if we add a method to type A, when now the method list for type B has to be changed. So we tell it, we're adding, and it rolls that foot. It rearranges the rows, yes, essentially. But the same rules apply, always in order, no gaps, and the order as defined in the thing. I could talk a little bit about that later.

Um, really demo question, but it's been a while since I've read ECMA 335. Yeah, it's been a few minutes from my time. Um, I remember that in the spec, it actually says that it's pointers into the various heaps like the method bodies and things like that. So I guess the dumb question is in terms of hot reload, wouldn't it be where you just change the pointer into a different, say, for example, you want to change your method body, you just have it point to a different stream and say, here you go, here's a new method body, for example.

Good question. Um, yeah, so you could do that, right? Instead of updating row nine, you could just say, you know, add on a row 10. Because there's no validation other than the fact that it has to be a valid method.

Exactly. Um, and in fact, I can kind of demo this later, but we could done it. We could say, yeah, add on a new row 10. The problem with that goes back to state. If you have a delegate, the points to method B, and I add on a new method B, where's your delegate point to? What does it run, which version of the code? And there's, so, and you know, you can probably answer that for method delegates, fine. But in terms of thinking about the state of your application, adding new stuff is easy for the runtime. But you get a much better experience if we can update all that stuff. So what the runtime will do, like, we've also, like I haven't talked about that method B gets jitted when it gets run. And then we have tiered compilation now, which jits over and over again.

Well, of course, if we update it, the runtime has to go and tell JIT, yep, throw out everything you know about B, start again, right? Like, there's all sorts of flow on effects here. So it could always just append. And in fact, there are some scenarios. So, uh, Razor, um, I don't know if you know this, hopefully you do. Razor files are generated in two C# backing files. And in Razor, some scenarios in Razor, we actually do essentially append. There's a flag that Razor tells the compiler that says, hey, if you see any changes to this type, don't worry about trying to update the type, just output an entirely new one. And so what was your Razor backing class, you know, through is now through underscore one. And the Razor runtime, the ASP.NET runtime has to then go and do a bunch of work to move all of its delegates and method pointers and model binding and all of its stuff to say, what, I forget about this class, this is the new one. And it's a lot of work. So it's, you know, Razor, ASP.NET can do it because they know the, you know, the context of how they're running. There's probably got a list of what's what it was. No, for the .NET runtime to do that in general. Like, you know, there's a bigger breadth of. Because I think the, the part that's missing here is that yes, it makes sense to update the tables. But if this is being done in memory, I've seen other approaches where people do a hot swap with delegates and things like that. Yeah. Does that mean it actually changes what's in memory? And how does that work with, you know, old style where you have to, you know, abdomen, you have to load it and unload it and all the other stuff. And how does that work out? Because you're not unloading it, obviously. No, no, no, what did you get? And you're changing the pointers in memory so that it actually works.

Yeah, I mean, so, so the, the thing about unloading a DLL and abdomen or whatever, that's, you know, that's essentially a runtime restriction. Right? So where hot reload, we're not, we're not cheating, right? This is a feature of the runtime. So the fact that they don't have to unload a DLL, well, they own the feed, they can, yeah, they can do that. And they can also say that you're not allowed to unload a DLL, but they are for hot reload. But they can totally do that. So we're not sort of cheating by trying to patch memory or anything. This is a feature, right? There is an apply updates method in the runtime, which is called and gets, there's three streams of bytes. There's the IL stream, the, the metadata stream and the PDB image. Like, so the way the runtime does it is, it doesn't necessarily, it's not necessarily congruent with other things in the runtime. The other thing with hot reload, so I'm talking about hot reload because it's the simplest scenario. But all of this code, all of this, the way this works, comes from edit and continue, which is why it's called the ENC log, edit and continue is more complicated because edit and continue happens at an even more granular level. So if we talk about state in edit and continue, it maintains the state of your local variables, right? It maintains the state of which statement in the method you're running. Hot reload doesn't have to worry about that, and I didn't want to have to talk about it, so I didn't. But so, some of this stuff also, it's like, maybe for hot reload, it makes sense to do it this other way, but edit and continue was already doing it the hard way anyway, and so hot reload just builds on that.

And that's, and last question is, where's this document? And so, for example, if I wanted to emit the IL for an assembly, and without the compiler, just, right?

Well, if you want to emit the IL, you're the compiler. I know, but if you wanted to append it because, for example, if there's like a small shim that you want to generate, and then you, is it just a matter of changing that table?

So, like, I'm just really curious as to how you actually get to it in terms of implementation.

Yeah, so this is where the documentation is lacking. So, as far as emitting the IL for the delta, it's just an ECMA-335 assembly essentially, and it has to follow all those same rules. The ENC log and ENC map are sadly undocumented, but- Because I looked at that and I was like, what's this?

Yeah, you would just have to look at the code in Roslyn. But I mean, it's not. It's also not very exciting. It is literally, I output a method. I output it at a time. It's just a compiler telling us what it did.

Yeah. If you come up ask, I can show you, there's tests in Roslyn that sort of maybe illustrate it pretty well.

Anyway, any more questions?

Yes, Aaron, hello. I'm just going to move to annoy the camera man. So, you showed a demo of that using it with a console application. Is this applicable for kind of anything that is running on the .NET runtime like that ASP.NET application or Windows Forms, and is it for cross-platform, or is it just a Visual Studio thing?

Good question. So, I'm going to answer that by going to the next slide, because it's kind of the second-last.

word there. But to answer your question, when at the start I said I'm talking about applying changes to a .NET assembly, and so therefore, it applies anywhere a .NET assembly can be run. So, a .NET assembly means via the spec that it has these metadata tables, and therefore hot reload when it says here's some new metadata tables. Well, that's what that means, just on a set. It's got nothing to do with platforms, it's got nothing to do with things. What it does have to do with these runtimes, so I will jump forward in this slide.

So, why are some things not hot reloadable, whatever rude edits? So, this is just a list of random examples of things that either are or used to be rude edits, but they're good examples of where in the process the blockers can be.

So, to answer your question, why do some things not work in Blazor WebAssembly?

So, Roslyn can detect all of your changes in a Blazor WebAssembly server. Blazor WebAssembly, not server. Project, the compiler can happily compile all of the metadata tables that it needs to to do all of the changes for a Blazor WebAssembly project, and in fact, the Blazor WebAssembly runtime will download that DLL if necessary, right?

All of these things are essentially universal. What's different specifically with Blazor WebAssembly is the runtime. Blazor WebAssembly uses the Mono runtime. And so, that step in the process where we give the delta to the runtime, the Mono runtime does not have the same feature set as far as which things in the ENC log it knows how to process. So, the Mono runtime can only do at the moment method body updates. That's it. So, you can modify methods, you can't add new ones, you can't add fields, you can't add properties, you can't change field initializers, there's a bunch of limits. And there's an API for the runtime to tell Roslyn what it can support.

So, Roslyn can report a rude edit in a Blazor WebAssembly that would work in a .NET 6 library. So, we know about what the runtime limitations are, and they're working on getting Mono more support, like seriously, like people work out. But so, that's where the limitations come in at the runtime level. So, all of this is produced as per the spec, and here's the things, but some runtimes don't have all the capabilities. And so, that's one reason you might get rude edits, and obviously, Blazor WebAssembly, it's a pretty big blocker at the moment because it does limit what you can do.

So, some other reasons for rude edits. Why couldn't you update records?

So, this one's past tense because you can now, because I did the work. So, one of the blockers is that whole thing of working out the changes, and mapping the changes back to a .NET-ism from a C#-ism means edit and continue, which is what the classes are called in Roslyn, Slash hot reload, has to be taught about every single C# feature. Now, some of them, well, some of them it doesn't actually have to be taught about, right? Like, the fact that you can now do a ref, or an in parameter, doesn't care, because that doesn't sort of, that doesn't escape out to the metadata world at all, that's a compiler thing. But for things like records, we have to teach Roslyn, okay, if they add a new record, here's what it means, or can they add a new record, right? If they update a record. So, for example, if you had a field to a record, versus adding a field to a class, adding field to a class, one new field, adding field to a record, one new field, change the constructor, change the copy constructor, change the equals method, the get hash code method, the print members method. Roslyn has to know all of that so that it can tell the compiler, these are all the methods you have to emit, so that it can put them all in the metadata, like so, we have to teach it all about all the C# features. Now, the compiler devs are supposed to do this, some of the big ones, they leave it for us, and we do a pass at the end. And so, well, the reason for the rude edits is the easiest way to teach Roslyn about a new compiler feature is to say, if you see this new compiler feature, it's a rude edit, that takes the box. So, there's number one. Why couldn't you update attributes? And I think, yes, this goes back to what you were asking about appending versus updating. So, attributes are interesting because they point back to the table. They come from more like a normal database, but the rules of ECMA 335 say that the attribute table has to be ordered by the parent column, which is the column that points to where it was.

So, if I add a new attribute to a method, I might have attribute for method 1, attribute for method 2, attribute for a property, attribute for a type. But if I want to add a method, I have to insert a row between two because the ordering has to be maintained. But that's going to affect all of the tokens for all of my other attributes, right? So, excuse me, the way to fix this, or the reason this was a rude edit, and the way we fix this is we added the capability or the smarts to the compiler that when it's emitting a delta compilation, it now knows how to output the custom attribute table in a way that the runtime will accept. And this is also something, in this case, we didn't have to in the end, but the way this project started was we went and go talk to the runtime devs and say, hey, how can we do this, right? Like, what do you need to know from us to be able to update this table? And it turned out they didn't actually need anything from us, we could just do it all on the Roslyn side. And essentially, every time there's a generation, we just re-output the entire custom attribute table. And actually, that's one of the benefits of this token system, the row is not special that it points to a method or a property, whatever, it's just a bit of data. And so, we just clobber, right? This row used to point to a property, great, points to a method, now bad luck. And so, you add a method, we want to insert a method, you know, in between rows two and three, well, actually, we just insert a method at the end, which the runtime can handle, but we rewrite all of the other methods. So, sometimes it's teaching the compiler new tricks. Why couldn't you add a await and yield return? So, this is that state machine table in metadata. It just didn't have enough information. So, async methods become a state machine, which means for every await in your method, there's a new state, so 1, 2, 3, 4, when you reload, we need to remember what state you're up to. But of course, if you add and await above where you are, then we have to change this one for us now. It's not state 4 anymore, it's now state 5. And so, that information is now in this new, well, not in the, it's in the PDB. So, sometimes it's writing more data to the PDB. But as it was, it's the runtime. And then generic types is the big one. I honestly don't know if this will ever be fixed, because this is a huge runtime limitation. The whole type system of .NET is affected if we ever have to change this. And so, sometimes we get these things like, yeah, I don't know, maybe we can't do that. Maybe we can, I don't know. All right, we have 10 more minutes. I'm now going to commit crimes. I love Hot Reload, because you can commit crimes. So, this is my favorite demo. I love it. Where's Visual Studio?

Okay, I'm going to run this code, run this app. And here is, this is kind of also back to the appending stuff, right?

So, here's my code. Great. I've got my three methods in reflection. No problem. I'm just going to delete that one. And I'll reload. Now, what happened there is we called C, and something went wrong. And now this code, this class, it has catches the exception. It runs again. You can see the clock is still ticking, right? They're still running. It's not fake. And there's still a method C in reflection. So, the runtime does not support deleting methods. But, we on the Roslyn team, we get telemetry about rude edits. So, we know, you know, any, in the last seven days, I could tell you how many times people ran into rude edit number four, two, three, or whatever. And one of the common ones is, well, one of the common ones is changing method signatures. But then in designing the feature, it boils down to deleting members is part of it. But so, we wanted to be able to delete methods even though the runtime can't. And so, we decided that we didn't care that the runtime can't. And so, what happens is, you delete a method, and in the compiler, there's a little bit of code that says, oh, you think you deleted that method? No, no, no, no. You updated that method. But, it's body now says, throw new MissingMethodException. So, we cheat, right? Normally, this wouldn't be a problem. The reason this is committing crimes is because if I scroll up, you'll see there's a compiler here. Right? C doesn't exist. The compiler doesn't know how to compile this method. But because we produced our list of edits, and I didn't touch this method, no one asked the compiler to compile this method. So, it didn't. So, there's a bit of IL that says, call method nine. The method nine still exists. It just has one line of code, and it says, throw new MissingMethodException. I love it, I love it so much. And I can put it back. And that works, and now we're back to calling C again.

And so, the whole point of this hot reload is, at runtime, yeah, that was really weird. Things grew up in ways that you definitely weren't expecting, right?

There's no way that all of your code has try catches. It's catch MissingMethodException, just in case someone deletes it at dev time. But, the point is, if you are a little bit resilient with your code, somewhere, I didn't have to restart my app. And that's the point of hot reload, right? That's what we want to do is, getting rid of the rude edits, maybe it doesn't make things work exactly the way you expect them to, but you at least don't have to restart your app.

So, all of your state is still there. I can do cool things like return string. So, if I do this, I think this is going to work, but boy, it might blow up. Yes, it works.

Okay. So, this one is, so that was changing method signature, right? And the reason we did deleting methods is because changing method signatures is built on top of deleting methods. Deleting methods is like the key to all of this. What happened is, I changed method C from void returning to string returning, and logically speaking as humans, we see that as the same method, but I changed the return type. And C# doesn't let you distinguish methods by return type, but .NET absolutely does. And so, that's what we did. So, when you update the return type or add a parameter or change your parameter type or rename a method, we delete the old one, throw MissingMethodException, which is what you're seeing there. And then we insert a new one, which has the same name and a different return type. And that's totally fine as far as metadata is concerned.

And so, now we can see on the right here, I have two methods. One is, this one is going to be inactive, right? This one's going to throw an exception, this one's active. If I reverse this, and I'll read it again, now we're back to calling C and we're happy. Still only two methods, but now, and you can't see this, you have to trust me, the one that returns a string, that one now throws a MissingMethodException. And we are working with the runtime, and hopefully we'll have some way to flag to them that we've done this crime, and then they can make reflection reflect that fact, or maybe they just will skip over it, like make it all make sense.

In general, though, if you're using reflection, and hot reload, kind of all bets are off. So, sorry, but at least so much we can do.

Anyway, I love that demo. And this is still on top, so that is really the end of the talk. So does anyone really have any questions, or you can go get, I guess, lunch.

Yes, hello. We'll wait for the mark. Hang on, wait. The method was never cleaned up, so it's not that it would be a real problem, but if you did hot reload three or four times, you'd have a lot of junk methods that'd be sitting in the assembly, right? Yeah, so that's true. If you keep changing the method signature over and over again to new ones every time, then there will be detractive methods left behind. But we are clever and we try to reuse them where we can. Like if the signature matches, so if you resurrect one, we will resurrect it. Where this gets cool is properties and events, because properties, so what you think of a property is not really a property, it's two methods in a trench coat. And so, when you change the, of the type of a property, we output a new get method, a new set method, so we have two to four, and then you change again and we have six. And events, if you're using VB are three methods in a trench coat, because there's an add or a move and a raise. C# doesn't have a raise, but of course, .NET has to have a raise. And Roslyn has to therefore understand raise. And I have to write VB code in order to make that work and I really hate myself.

Any, I think there was another question. Thank you.

## .NET 6 Hot Reload Discussions<a name="net-6-hot-reload-discussions"></a>

All right, let's start from modern runtime. Was runtime rewritten in .NET 6?

I only saw modern runtime in something related to OmniSharp and to connect. No, I mean, .NET 6 has traces of TerraFX back a long way. It wasn't a rewrite of .NET Framework, or anything. But I mean, edit and continue has been in, like, was in .NET Framework very early on. So, the bones of all of this have been there. And in .NET 6, with Hot Reload being, you know, the marketing, Hot Reload of XAML and XAML and all of those things, it got a bunch of, you know, it was good because it funded a bunch of work and so it got a bunch more smarts around it. Things like you can create a class in your assembly and tag it with an attribute. And then after a Hot Reload occurs, the runtime will call your code and tell you which types were changed, which is how ASP.NET does its whole, hey, there's a new view for this. And so you can actually make your code work or your application work better with Hot Reload by maybe there's some case that you need to invalidate. It's like I've got a little train game and it's very, like, it's written terribly. So in order to get decent performance, I cache a lot of stuff. So you draw out the tracks and then I save that image of what those tracks look like and I never draw it again. But of course, when I hot reload, that's now a problem. So I have a little thing and I tag it with the attribute and I invalidate my cache every time I do a hot reload. And now my dev loop while I'm working on my project is a bit better. So the runtime does get new features and stuff. But yeah, all of this stuff traces its lineage back to edit and continue back in .NET Framework, whatever it was. I was saying this because I think you mentioned there was something that modern runtime couldn't do and- The Mono runtime. So Mono is the runtime used in Blazor WebAssembly, and it only supports method body updates at the moment. But they are actively working on- Like, it also now supports lambda updates, which are really just method body updates, but in a separate type. And so there's a bunch of work that has been done. It's not quite sort of visible to us as users yet. When they get to like add new field, add new property, that's when the majority of the rude edits should hopefully fall away. Cool.

So you actually started answering my other question. So for example, I, when using hot reload, I realized in ASP.NET specifically, there are certain areas that struggle. One area kind of makes sense, if you have something in the start up, registrations. Some other things like, for example, if you modify an AutoMapper, mapping something like that, that also doesn't get clicked up.

Yeah. So that's a very good question, at a good point. I probably should have mentioned, but I didn't, but I wouldn't know. Hot reload updates your code. So when you change your start up class, I can promise you hot reload is updating that start up class. The problem is, nothing ever calls that to be run again, right? That's my my console app has a loop. This has a wild root because I can apply the same hot reloads, but if nothing runs the new code or the old code or whatever, then you don't see the changes. So things like start up classes or AutoMapper, that's up to ASP.NET to work out how they're going to do that. So they can put that attribute on, and they can somehow call start up again, but without breaking the world, I don't know, but that's up to them. So is there anything actually that is available to real end users to, for example, say, when I change this, just restart, saying, for me, instead of me pressing Ctrl C, Ctrl R? For the web specifically, I don't know. In general, like, is there, for example, an attribute, put an attribute on these classes, and if it changes...

Yeah, so you would write a class that you put the attribute on, and then that class knows how to do whatever. So it gets called when there's a change, but you would have to write the smarts for what to do to react to that change. We should probably let these people go get lunch before the queue gets big, but I'm happy to talk afterwards if you want.

Thank you, everybody.